use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;
use std::collections::HashMap;

// Error types for robust error handling
#[derive(Debug, thiserror::Error)]
pub enum CartTransformError {
    #[error("JSON parsing error: {0}")]
    JsonParse(#[from] serde_json::Error),
    #[error("Invalid add-on configuration: {0}")]
    InvalidAddonConfig(String),
    #[error("Missing required property: {0}")]
    MissingProperty(String),
}

// Result type for all operations
pub type CartTransformResult<T> = Result<T, CartTransformError>;

// Core data structures - exactly matching our JavaScript logic
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cart {
    pub id: Option<String>,
    pub note: Option<String>,
    pub attributes: Option<HashMap<String, serde_json::Value>>,
    pub original_total_price: Option<i64>,
    pub total_price: Option<i64>,
    pub total_discount: Option<i64>,
    pub total_weight: Option<i64>,
    pub item_count: Option<i64>,
    pub items: Option<Vec<CartItem>>,
    pub requires_shipping: Option<bool>,
    pub currency: Option<String>,
    pub items_subtotal_price: Option<i64>,
    pub cart_level_discount_applications: Option<Vec<serde_json::Value>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CartItem {
    pub id: Option<i64>,
    pub variant_id: Option<i64>,
    pub key: Option<String>,
    pub title: Option<String>,
    pub price: Option<i64>,
    pub original_price: Option<i64>,
    pub discounted_price: Option<i64>,
    pub line_price: Option<i64>,
    pub original_line_price: Option<i64>,
    pub final_price: Option<i64>,
    pub final_line_price: Option<i64>,
    pub quantity: Option<i64>,
    pub sku: Option<String>,
    pub grams: Option<i64>,
    pub vendor: Option<String>,
    pub taxable: Option<bool>,
    pub product_id: Option<i64>,
    pub product_title: Option<String>,
    pub product_description: Option<String>,
    pub product_type: Option<String>,
    pub product_has_only_default_variant: Option<bool>,
    pub gift_card: Option<bool>,
    pub requires_shipping: Option<bool>,
    pub url: Option<String>,
    pub image: Option<String>,
    pub handle: Option<String>,
    pub properties: Option<HashMap<String, serde_json::Value>>,
    pub options_with_values: Option<Vec<serde_json::Value>>,
    pub line_level_discount_allocations: Option<Vec<serde_json::Value>>,
    pub line_level_total_discount: Option<i64>,
    pub total_discount: Option<i64>,
    pub discounts: Option<Vec<serde_json::Value>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddonConfig {
    pub title: String,
    pub price: f64,
    pub sku: Option<String>,
    pub description: Option<String>,
    pub weight_grams: Option<i64>,
    pub is_taxable: Option<bool>,
    pub requires_shipping: Option<bool>,
    pub image_url: Option<String>,
}



// Memory initialization for Shoplazza 2025 compatibility
#[wasm_bindgen(start)]
pub fn init() {
    // Initialize memory and global state
    // This is required for Shoplazza's 2025 WASM runtime
}

// Main entry point for WASM - must match Shoplazza's expected signature
#[wasm_bindgen(js_name = "processCart")]
pub fn process_cart(cart_json: &str) -> Result<String, JsValue> {
    // Parse input cart
    let cart: Cart = serde_json::from_str(cart_json)
        .map_err(|e| JsValue::from_str(&format!("JSON parse error: {}", e)))?;
    
    // Process cart with add-ons
    let modified_cart = process_cart_with_addons(&cart)
        .map_err(|e| JsValue::from_str(&format!("Processing error: {}", e)))?;
    
    // Serialize result
    let result_json = serde_json::to_string(&modified_cart)
        .map_err(|e| JsValue::from_str(&format!("JSON serialize error: {}", e)))?;
    
    Ok(result_json)
}

// Core cart processing logic - EXACTLY matching our JavaScript
pub fn process_cart_with_addons(cart: &Cart) -> CartTransformResult<Cart> {
    let mut modified_cart = cart.clone();
    let mut addon_line_items: Vec<CartItem> = Vec::new();
    let mut processed_indices: Vec<usize> = Vec::new();
    
    // First pass: collect add-on line items and track which items need processing
    if let Some(ref items) = modified_cart.items {
        for (item_index, item) in items.iter().enumerate() {
            // Skip if already processed
            if let Some(ref properties) = item.properties {
                if properties.get("_add_on_processed")
                    .and_then(|v| v.as_str())
                    .map(|s| s == "true")
                    .unwrap_or(false) {
                    continue;
                }
            }
            
            // Phase 2: Direct add-on properties
            {
                if let Some(ref properties) = item.properties {
                    if let (Some(addon_type), Some(addon_name)) = (
                        properties.get("_add_on_type").and_then(|v| v.as_str()),
                        properties.get("_add_on_name").and_then(|v| v.as_str())
                    ) {
                        if addon_type == "protection_plan" {
                            let addon_config = AddonConfig {
                                title: addon_name.to_string(),
                                price: properties.get("_add_on_price")
                                    .and_then(|v| v.as_str())
                                    .and_then(|s| s.parse::<f64>().ok())
                                    .unwrap_or(0.0),
                                sku: properties.get("_add_on_sku")
                                    .and_then(|v| v.as_str())
                                    .map(|s| s.to_string()),
                                description: properties.get("_add_on_description")
                                    .and_then(|v| v.as_str())
                                    .map(|s| s.to_string()),
                                weight_grams: None,
                                is_taxable: Some(true),
                                requires_shipping: Some(false),
                                image_url: None,
                            };
                            
                            if !addon_config.title.is_empty() {
                                let addon_cost = calculate_addon_cost(&addon_config, item.quantity.unwrap_or(1));
                                let addon_line_item = create_addon_line_item(&addon_config, addon_cost, item);
                                addon_line_items.push(addon_line_item);
                                processed_indices.push(item_index);
                            }
                        }
                    }
                }
            }
            
            // Phase 2: Compressed add-on data
            {
                if let Some(ref properties) = item.properties {
                    if let (Some(compressed), Some(_addon_data)) = (
                        properties.get("_compressed").and_then(|v| v.as_str()),
                        properties.get("_add_on_data").and_then(|v| v.as_str())
                    ) {
                        if compressed == "true" {
                            // Note: We'll need to implement base64 decoding
                            // For now, we'll handle this in the JavaScript wrapper
                            continue;
                        }
                    }
                }
            }
            
            // Legacy Phase 1 support
            {
                if let Some(ref properties) = item.properties {
                    if let (Some(addon_config_str), Some(addon_selected)) = (
                        properties.get("_addon_config").and_then(|v| v.as_str()),
                        properties.get("_addon_selected").and_then(|v| v.as_str())
                    ) {
                        if addon_selected == "true" {
                            if let Ok(addon_config) = serde_json::from_str::<AddonConfig>(addon_config_str) {
                                if !addon_config.title.is_empty() {
                                    let addon_cost = calculate_addon_cost(&addon_config, item.quantity.unwrap_or(1));
                                    let addon_line_item = create_addon_line_item(&addon_config, addon_cost, item);
                                    addon_line_items.push(addon_line_item);
                                    processed_indices.push(item_index);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Second pass: modify original items and mark as processed
    if let Some(ref mut items) = modified_cart.items {
        for &item_index in &processed_indices {
            if let Some(item) = items.get_mut(item_index) {
                if let Some(ref mut properties) = item.properties {
                    properties.insert("_add_on_processed".to_string(), serde_json::Value::String("true".to_string()));
                    properties.insert("_addon_applied".to_string(), serde_json::Value::String("true".to_string()));
                } else {
                    let mut new_properties = HashMap::new();
                    new_properties.insert("_add_on_processed".to_string(), serde_json::Value::String("true".to_string()));
                    new_properties.insert("_addon_applied".to_string(), serde_json::Value::String("true".to_string()));
                    item.properties = Some(new_properties);
                }
            }
        }
    }
    
    // Add add-on line items to cart
    if !addon_line_items.is_empty() {
        if let Some(ref mut items) = modified_cart.items {
            items.extend(addon_line_items);
        } else {
            modified_cart.items = Some(addon_line_items);
        }
        
        // Update cart totals
        update_cart_totals(&mut modified_cart);
    }
    
    Ok(modified_cart)
}

// Helper functions - EXACTLY matching our JavaScript logic
fn calculate_addon_cost(addon_config: &AddonConfig, quantity: i64) -> i64 {
    let base_price = addon_config.price;
    (base_price * 100.0 * quantity as f64).round() as i64
}

fn create_addon_line_item(addon_config: &AddonConfig, addon_cost: i64, original_item: &CartItem) -> CartItem {
    let timestamp = chrono::Utc::now().timestamp_millis();
    let addon_id = format!("addon_{}_{}", original_item.id.unwrap_or(0), timestamp);
    
    let mut properties = HashMap::new();
    properties.insert("_addon_type".to_string(), serde_json::Value::String("shoplazza_addon".to_string()));
    properties.insert("_addon_for_item".to_string(), serde_json::Value::String(original_item.variant_id.unwrap_or(0).to_string()));
    properties.insert("_addon_config".to_string(), serde_json::Value::String(serde_json::to_string(addon_config).unwrap_or_default()));
    properties.insert("_addon_source".to_string(), serde_json::Value::String("widget_selection".to_string()));
    
    CartItem {
        id: Some(addon_id.parse::<i64>().unwrap_or(0)),
        variant_id: Some(format!("addon_variant_{}_{}", original_item.variant_id.unwrap_or(0), timestamp).parse::<i64>().unwrap_or(0)),
        key: Some(format!("addon_{}_{}", original_item.key.as_ref().unwrap_or(&"variant".to_string()), timestamp)),
        title: Some(addon_config.title.clone()),
        price: Some(addon_cost),
        original_price: Some(addon_cost),
        discounted_price: Some(addon_cost),
        line_price: Some(addon_cost),
        original_line_price: Some(addon_cost),
        final_price: Some(addon_cost),
        final_line_price: Some(addon_cost),
        quantity: Some(original_item.quantity.unwrap_or(1)),
        sku: Some(addon_config.sku.clone().unwrap_or_else(|| "ADDON-001".to_string())),
        grams: Some(addon_config.weight_grams.unwrap_or(0)),
        vendor: Some("Add-on System".to_string()),
        taxable: Some(addon_config.is_taxable.unwrap_or(true)),
        product_id: Some(format!("addon_product_{}_{}", original_item.product_id.unwrap_or(0), timestamp).parse::<i64>().unwrap_or(0)),
        product_title: Some(addon_config.title.clone()),
        product_description: Some(addon_config.description.clone().unwrap_or_default()),
        product_type: Some("add-on".to_string()),
        product_has_only_default_variant: Some(true),
        gift_card: Some(false),
        requires_shipping: Some(addon_config.requires_shipping.unwrap_or(false)),
        url: Some("".to_string()),
        image: Some(addon_config.image_url.clone().unwrap_or_default()),
        handle: Some(format!("addon-{}", original_item.handle.as_ref().unwrap_or(&"product".to_string()))),
        properties: Some(properties),
        options_with_values: Some(Vec::new()),
        line_level_discount_allocations: Some(Vec::new()),
        line_level_total_discount: Some(0),
        total_discount: Some(0),
        discounts: Some(Vec::new()),
    }
}



fn update_cart_totals(cart: &mut Cart) {
    if let Some(ref items) = cart.items {
        let mut items_subtotal = 0i64;
        let mut total_price = 0i64;
        let mut total_weight = 0i64;
        let mut item_count = 0i64;
        
        for item in items {
            let item_total = item.final_line_price
                .or(item.line_price)
                .or_else(|| item.price.map(|p| p * item.quantity.unwrap_or(1)))
                .unwrap_or(0);
            
            items_subtotal += item_total;
            total_price += item_total;
            total_weight += item.grams.unwrap_or(0) * item.quantity.unwrap_or(1);
            item_count += item.quantity.unwrap_or(1);
        }
        
        cart.items_subtotal_price = Some(items_subtotal);
        cart.total_price = Some(total_price);
        cart.total_weight = Some(total_weight);
        cart.item_count = Some(item_count);
    }
}

// Test module
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_calculate_addon_cost() {
        let config = AddonConfig {
            title: "Test".to_string(),
            price: 9.99,
            sku: None,
            description: None,
            weight_grams: None,
            is_taxable: None,
            requires_shipping: None,
            image_url: None,
        };
        
        assert_eq!(calculate_addon_cost(&config, 2), 1998); // 9.99 * 100 * 2 = 1998
    }
    
    #[test]
    fn test_create_addon_line_item() {
        let config = AddonConfig {
            title: "Protection".to_string(),
            price: 5.99,
            sku: Some("PROT-001".to_string()),
            description: Some("Test description".to_string()),
            weight_grams: Some(0),
            is_taxable: Some(true),
            requires_shipping: Some(false),
            image_url: None,
        };
        
        let original_item = CartItem {
            id: Some(1),
            variant_id: Some(123),
            key: Some("variant_123".to_string()),
            title: Some("Test Product".to_string()),
            price: Some(1000),
            quantity: Some(2),
            product_id: Some(456),
            handle: Some("test-product".to_string()),
            ..Default::default()
        };
        
        let addon_item = create_addon_line_item(&config, 1198, &original_item);
        
        assert_eq!(addon_item.title, Some("Protection".to_string()));
        assert_eq!(addon_item.price, Some(1198));
        assert_eq!(addon_item.quantity, Some(2));
        assert_eq!(addon_item.sku, Some("PROT-001".to_string()));
        assert_eq!(addon_item.vendor, Some("Add-on System".to_string()));
    }
}

// Implement Default for CartItem to make testing easier
impl Default for CartItem {
    fn default() -> Self {
        Self {
            id: None,
            variant_id: None,
            key: None,
            title: None,
            price: None,
            original_price: None,
            discounted_price: None,
            line_price: None,
            original_line_price: None,
            final_price: None,
            final_line_price: None,
            quantity: None,
            sku: None,
            grams: None,
            vendor: None,
            taxable: None,
            product_id: None,
            product_title: None,
            product_description: None,
            product_type: None,
            product_has_only_default_variant: None,
            gift_card: None,
            requires_shipping: None,
            url: None,
            image: None,
            handle: None,
            properties: None,
            options_with_values: None,
            line_level_discount_allocations: None,
            line_level_total_discount: None,
            total_discount: None,
            discounts: None,
        }
    }
}
